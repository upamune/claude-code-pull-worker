// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: api_keys.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (webhook_id, key_hash, key_prefix, key_suffix, description)
VALUES (?, ?, ?, ?, ?)
RETURNING id, webhook_id, key_hash, key_prefix, key_suffix, description, is_active, created_at, last_used_at
`

type CreateAPIKeyParams struct {
	WebhookID   string         `json:"webhook_id"`
	KeyHash     string         `json:"key_hash"`
	KeyPrefix   string         `json:"key_prefix"`
	KeySuffix   string         `json:"key_suffix"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createAPIKey,
		arg.WebhookID,
		arg.KeyHash,
		arg.KeyPrefix,
		arg.KeySuffix,
		arg.Description,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.KeySuffix,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
UPDATE api_keys SET is_active = 0 WHERE id = ?
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, id)
	return err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, webhook_id, key_hash, key_prefix, key_suffix, description, is_active, created_at, last_used_at FROM api_keys 
WHERE key_hash = ? AND is_active = 1
`

func (q *Queries) GetAPIKeyByHash(ctx context.Context, keyHash string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByHash, keyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.KeySuffix,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getAPIKeyWithWebhook = `-- name: GetAPIKeyWithWebhook :one
SELECT 
    ak.id, ak.webhook_id, ak.key_hash, ak.key_prefix, ak.key_suffix, ak.description, ak.is_active, ak.created_at, ak.last_used_at,
    w.name as webhook_name,
    w.claude_options,
    w.notification_config
FROM api_keys ak
JOIN webhooks w ON ak.webhook_id = w.id
WHERE ak.key_hash = ? AND ak.is_active = 1 AND w.is_active = 1
`

type GetAPIKeyWithWebhookRow struct {
	ID                 int64          `json:"id"`
	WebhookID          string         `json:"webhook_id"`
	KeyHash            string         `json:"key_hash"`
	KeyPrefix          string         `json:"key_prefix"`
	KeySuffix          string         `json:"key_suffix"`
	Description        sql.NullString `json:"description"`
	IsActive           bool           `json:"is_active"`
	CreatedAt          time.Time      `json:"created_at"`
	LastUsedAt         sql.NullTime   `json:"last_used_at"`
	WebhookName        string         `json:"webhook_name"`
	ClaudeOptions      interface{}    `json:"claude_options"`
	NotificationConfig interface{}    `json:"notification_config"`
}

func (q *Queries) GetAPIKeyWithWebhook(ctx context.Context, keyHash string) (GetAPIKeyWithWebhookRow, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyWithWebhook, keyHash)
	var i GetAPIKeyWithWebhookRow
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.KeyHash,
		&i.KeyPrefix,
		&i.KeySuffix,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.WebhookName,
		&i.ClaudeOptions,
		&i.NotificationConfig,
	)
	return i, err
}

const getAPIKeysForWebhook = `-- name: GetAPIKeysForWebhook :many
SELECT id, webhook_id, key_hash, key_prefix, key_suffix, description, is_active, created_at, last_used_at FROM api_keys
WHERE webhook_id = ? AND is_active = 1
`

func (q *Queries) GetAPIKeysForWebhook(ctx context.Context, webhookID string) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, getAPIKeysForWebhook, webhookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.KeyHash,
			&i.KeyPrefix,
			&i.KeySuffix,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPIKeysByWebhook = `-- name: ListAPIKeysByWebhook :many
SELECT id, webhook_id, key_prefix, key_suffix, description, created_at, last_used_at
FROM api_keys 
WHERE webhook_id = ? AND is_active = 1
ORDER BY created_at DESC
`

type ListAPIKeysByWebhookRow struct {
	ID          int64          `json:"id"`
	WebhookID   string         `json:"webhook_id"`
	KeyPrefix   string         `json:"key_prefix"`
	KeySuffix   string         `json:"key_suffix"`
	Description sql.NullString `json:"description"`
	CreatedAt   time.Time      `json:"created_at"`
	LastUsedAt  sql.NullTime   `json:"last_used_at"`
}

func (q *Queries) ListAPIKeysByWebhook(ctx context.Context, webhookID string) ([]ListAPIKeysByWebhookRow, error) {
	rows, err := q.db.QueryContext(ctx, listAPIKeysByWebhook, webhookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAPIKeysByWebhookRow{}
	for rows.Next() {
		var i ListAPIKeysByWebhookRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.KeyPrefix,
			&i.KeySuffix,
			&i.Description,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET last_used_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed, id)
	return err
}
