// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: security_audit_logs.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countSecurityAuditEvents = `-- name: CountSecurityAuditEvents :one
SELECT COUNT(*) FROM security_audit_logs
WHERE webhook_id = ? AND created_at > ?
`

type CountSecurityAuditEventsParams struct {
	WebhookID string    `json:"webhook_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CountSecurityAuditEvents(ctx context.Context, arg CountSecurityAuditEventsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSecurityAuditEvents, arg.WebhookID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentSecurityAuditLogs = `-- name: GetRecentSecurityAuditLogs :many
SELECT id, webhook_id, event_type, client_ip, user_agent, api_key_provided, error_message, request_path, created_at FROM security_audit_logs
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentSecurityAuditLogs(ctx context.Context, limit int64) ([]SecurityAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getRecentSecurityAuditLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityAuditLog{}
	for rows.Next() {
		var i SecurityAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.ClientIp,
			&i.UserAgent,
			&i.ApiKeyProvided,
			&i.ErrorMessage,
			&i.RequestPath,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityAuditLogs = `-- name: GetSecurityAuditLogs :many
SELECT id, webhook_id, event_type, client_ip, user_agent, api_key_provided, error_message, request_path, created_at FROM security_audit_logs
WHERE webhook_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetSecurityAuditLogsParams struct {
	WebhookID string `json:"webhook_id"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) GetSecurityAuditLogs(ctx context.Context, arg GetSecurityAuditLogsParams) ([]SecurityAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityAuditLogs, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityAuditLog{}
	for rows.Next() {
		var i SecurityAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.ClientIp,
			&i.UserAgent,
			&i.ApiKeyProvided,
			&i.ErrorMessage,
			&i.RequestPath,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityAuditLogsByIP = `-- name: GetSecurityAuditLogsByIP :many
SELECT id, webhook_id, event_type, client_ip, user_agent, api_key_provided, error_message, request_path, created_at FROM security_audit_logs
WHERE client_ip = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetSecurityAuditLogsByIPParams struct {
	ClientIp string `json:"client_ip"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) GetSecurityAuditLogsByIP(ctx context.Context, arg GetSecurityAuditLogsByIPParams) ([]SecurityAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityAuditLogsByIP, arg.ClientIp, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityAuditLog{}
	for rows.Next() {
		var i SecurityAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.ClientIp,
			&i.UserAgent,
			&i.ApiKeyProvided,
			&i.ErrorMessage,
			&i.RequestPath,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityAuditLogsByType = `-- name: GetSecurityAuditLogsByType :many
SELECT id, webhook_id, event_type, client_ip, user_agent, api_key_provided, error_message, request_path, created_at FROM security_audit_logs
WHERE webhook_id = ? AND event_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetSecurityAuditLogsByTypeParams struct {
	WebhookID string `json:"webhook_id"`
	EventType string `json:"event_type"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) GetSecurityAuditLogsByType(ctx context.Context, arg GetSecurityAuditLogsByTypeParams) ([]SecurityAuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getSecurityAuditLogsByType,
		arg.WebhookID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityAuditLog{}
	for rows.Next() {
		var i SecurityAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.ClientIp,
			&i.UserAgent,
			&i.ApiKeyProvided,
			&i.ErrorMessage,
			&i.RequestPath,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logSecurityAuditEvent = `-- name: LogSecurityAuditEvent :exec
INSERT INTO security_audit_logs (
    webhook_id,
    event_type,
    client_ip,
    user_agent,
    api_key_provided,
    error_message,
    request_path
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type LogSecurityAuditEventParams struct {
	WebhookID      string         `json:"webhook_id"`
	EventType      string         `json:"event_type"`
	ClientIp       string         `json:"client_ip"`
	UserAgent      sql.NullString `json:"user_agent"`
	ApiKeyProvided sql.NullString `json:"api_key_provided"`
	ErrorMessage   sql.NullString `json:"error_message"`
	RequestPath    sql.NullString `json:"request_path"`
}

func (q *Queries) LogSecurityAuditEvent(ctx context.Context, arg LogSecurityAuditEventParams) error {
	_, err := q.db.ExecContext(ctx, logSecurityAuditEvent,
		arg.WebhookID,
		arg.EventType,
		arg.ClientIp,
		arg.UserAgent,
		arg.ApiKeyProvided,
		arg.ErrorMessage,
		arg.RequestPath,
	)
	return err
}
