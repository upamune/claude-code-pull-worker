// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_queue.sql

package db

import (
	"context"
	"database/sql"
)

const completeJob = `-- name: CompleteJob :exec
UPDATE job_queue
SET 
    status = 'completed',
    completed_at = CURRENT_TIMESTAMP,
    response = ?,
    execution_time_ms = ?
WHERE id = ? AND status = 'processing'
`

type CompleteJobParams struct {
	Response        sql.NullString `json:"response"`
	ExecutionTimeMs sql.NullInt64  `json:"execution_time_ms"`
	ID              int64          `json:"id"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) error {
	_, err := q.db.ExecContext(ctx, completeJob, arg.Response, arg.ExecutionTimeMs, arg.ID)
	return err
}

const dequeueJob = `-- name: DequeueJob :one
UPDATE job_queue
SET 
    status = 'processing',
    started_at = CURRENT_TIMESTAMP,
    visibility_timeout = datetime('now', '+10 minutes'),
    worker_id = ?
WHERE id = (
    SELECT id FROM job_queue
    WHERE status = 'pending'
       OR (status = 'processing' AND visibility_timeout < CURRENT_TIMESTAMP)
    ORDER BY priority DESC, created_at ASC
    LIMIT 1
)
RETURNING id, webhook_id, api_key_id, prompt, context, claude_options, status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at
`

func (q *Queries) DequeueJob(ctx context.Context, workerID sql.NullString) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, dequeueJob, workerID)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.Context,
		&i.ClaudeOptions,
		&i.Status,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO job_queue (
    webhook_id,
    api_key_id,
    prompt,
    context,
    claude_options,
    priority
) VALUES (
    ?, ?, ?, ?, ?, ?
) RETURNING id, webhook_id, api_key_id, prompt, context, claude_options, status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at
`

type EnqueueJobParams struct {
	WebhookID     string         `json:"webhook_id"`
	ApiKeyID      sql.NullInt64  `json:"api_key_id"`
	Prompt        string         `json:"prompt"`
	Context       sql.NullString `json:"context"`
	ClaudeOptions sql.NullString `json:"claude_options"`
	Priority      int64          `json:"priority"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, enqueueJob,
		arg.WebhookID,
		arg.ApiKeyID,
		arg.Prompt,
		arg.Context,
		arg.ClaudeOptions,
		arg.Priority,
	)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.Context,
		&i.ClaudeOptions,
		&i.Status,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const failJob = `-- name: FailJob :exec
UPDATE job_queue
SET 
    status = CASE 
        WHEN retry_count >= max_retries THEN 'failed'
        ELSE 'pending'
    END,
    retry_count = retry_count + 1,
    error_message = ?,
    visibility_timeout = NULL,
    worker_id = NULL
WHERE id = ? AND status = 'processing'
`

type FailJobParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           int64          `json:"id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.ErrorMessage, arg.ID)
	return err
}

const getJobStatus = `-- name: GetJobStatus :one
SELECT id, webhook_id, api_key_id, prompt, context, claude_options, status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at FROM job_queue WHERE id = ?
`

func (q *Queries) GetJobStatus(ctx context.Context, id int64) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, getJobStatus, id)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.Context,
		&i.ClaudeOptions,
		&i.Status,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getJobsByWebhook = `-- name: GetJobsByWebhook :many
SELECT id, webhook_id, api_key_id, prompt, context, claude_options, status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at FROM job_queue
WHERE webhook_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetJobsByWebhookParams struct {
	WebhookID string `json:"webhook_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetJobsByWebhook(ctx context.Context, arg GetJobsByWebhookParams) ([]JobQueue, error) {
	rows, err := q.db.QueryContext(ctx, getJobsByWebhook, arg.WebhookID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobQueue{}
	for rows.Next() {
		var i JobQueue
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.ApiKeyID,
			&i.Prompt,
			&i.Context,
			&i.ClaudeOptions,
			&i.Status,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.WorkerID,
			&i.VisibilityTimeout,
			&i.ErrorMessage,
			&i.Response,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingJobCount = `-- name: GetPendingJobCount :one
SELECT COUNT(*) as count FROM job_queue WHERE status = 'pending'
`

func (q *Queries) GetPendingJobCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingJobCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentJobs = `-- name: GetRecentJobs :many
SELECT id, webhook_id, api_key_id, prompt, context, claude_options, status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at FROM job_queue
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentJobs(ctx context.Context, limit int64) ([]JobQueue, error) {
	rows, err := q.db.QueryContext(ctx, getRecentJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobQueue{}
	for rows.Next() {
		var i JobQueue
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.ApiKeyID,
			&i.Prompt,
			&i.Context,
			&i.ClaudeOptions,
			&i.Status,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.WorkerID,
			&i.VisibilityTimeout,
			&i.ErrorMessage,
			&i.Response,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStaleJobs = `-- name: ResetStaleJobs :exec
UPDATE job_queue
SET 
    status = 'pending',
    visibility_timeout = NULL,
    worker_id = NULL
WHERE status = 'processing' 
  AND visibility_timeout < CURRENT_TIMESTAMP
`

func (q *Queries) ResetStaleJobs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetStaleJobs)
	return err
}
