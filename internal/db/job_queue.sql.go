// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: job_queue.sql

package db

import (
	"context"
	"database/sql"
)

const completeJob = `-- name: CompleteJob :exec
UPDATE job_queue
SET 
    job_status = 'completed',
    completed_at = CURRENT_TIMESTAMP,
    response = ?,
    execution_time_ms = ?
WHERE id = ? AND job_status = 'processing'
`

type CompleteJobParams struct {
	Response        sql.NullString `json:"response"`
	ExecutionTimeMs sql.NullInt64  `json:"execution_time_ms"`
	ID              int64          `json:"id"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) error {
	_, err := q.db.ExecContext(ctx, completeJob, arg.Response, arg.ExecutionTimeMs, arg.ID)
	return err
}

const dequeueJob = `-- name: DequeueJob :one
UPDATE job_queue
SET 
    job_status = 'processing',
    started_at = CURRENT_TIMESTAMP,
    visibility_timeout = datetime('now', '+10 minutes'),
    worker_id = ?
WHERE id = (
    SELECT id FROM job_queue
    WHERE job_status = 'pending'
       OR (job_status = 'processing' AND visibility_timeout < CURRENT_TIMESTAMP)
    ORDER BY priority DESC, created_at ASC
    LIMIT 1
)
RETURNING id, webhook_id, api_key_id, prompt, job_status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at, working_dir, max_thinking_tokens, max_turns, custom_system_prompt, append_system_prompt, allowed_tools, disallowed_tools, permission_mode, permission_prompt_tool_name, model, fallback_model, mcp_servers, enable_continue, continue_minutes
`

func (q *Queries) DequeueJob(ctx context.Context, workerID sql.NullString) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, dequeueJob, workerID)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.JobStatus,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.WorkingDir,
		&i.MaxThinkingTokens,
		&i.MaxTurns,
		&i.CustomSystemPrompt,
		&i.AppendSystemPrompt,
		&i.AllowedTools,
		&i.DisallowedTools,
		&i.PermissionMode,
		&i.PermissionPromptToolName,
		&i.Model,
		&i.FallbackModel,
		&i.McpServers,
		&i.EnableContinue,
		&i.ContinueMinutes,
	)
	return i, err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO job_queue (
    webhook_id,
    api_key_id,
    prompt,
    priority,
    working_dir,
    max_thinking_tokens,
    max_turns,
    custom_system_prompt,
    append_system_prompt,
    allowed_tools,
    disallowed_tools,
    permission_mode,
    permission_prompt_tool_name,
    model,
    fallback_model,
    mcp_servers,
    enable_continue,
    continue_minutes
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, webhook_id, api_key_id, prompt, job_status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at, working_dir, max_thinking_tokens, max_turns, custom_system_prompt, append_system_prompt, allowed_tools, disallowed_tools, permission_mode, permission_prompt_tool_name, model, fallback_model, mcp_servers, enable_continue, continue_minutes
`

type EnqueueJobParams struct {
	WebhookID                string         `json:"webhook_id"`
	ApiKeyID                 sql.NullInt64  `json:"api_key_id"`
	Prompt                   string         `json:"prompt"`
	Priority                 int64          `json:"priority"`
	WorkingDir               sql.NullString `json:"working_dir"`
	MaxThinkingTokens        sql.NullInt64  `json:"max_thinking_tokens"`
	MaxTurns                 sql.NullInt64  `json:"max_turns"`
	CustomSystemPrompt       sql.NullString `json:"custom_system_prompt"`
	AppendSystemPrompt       sql.NullString `json:"append_system_prompt"`
	AllowedTools             sql.NullString `json:"allowed_tools"`
	DisallowedTools          sql.NullString `json:"disallowed_tools"`
	PermissionMode           sql.NullString `json:"permission_mode"`
	PermissionPromptToolName sql.NullString `json:"permission_prompt_tool_name"`
	Model                    sql.NullString `json:"model"`
	FallbackModel            sql.NullString `json:"fallback_model"`
	McpServers               sql.NullString `json:"mcp_servers"`
	EnableContinue           bool           `json:"enable_continue"`
	ContinueMinutes          int64          `json:"continue_minutes"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, enqueueJob,
		arg.WebhookID,
		arg.ApiKeyID,
		arg.Prompt,
		arg.Priority,
		arg.WorkingDir,
		arg.MaxThinkingTokens,
		arg.MaxTurns,
		arg.CustomSystemPrompt,
		arg.AppendSystemPrompt,
		arg.AllowedTools,
		arg.DisallowedTools,
		arg.PermissionMode,
		arg.PermissionPromptToolName,
		arg.Model,
		arg.FallbackModel,
		arg.McpServers,
		arg.EnableContinue,
		arg.ContinueMinutes,
	)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.JobStatus,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.WorkingDir,
		&i.MaxThinkingTokens,
		&i.MaxTurns,
		&i.CustomSystemPrompt,
		&i.AppendSystemPrompt,
		&i.AllowedTools,
		&i.DisallowedTools,
		&i.PermissionMode,
		&i.PermissionPromptToolName,
		&i.Model,
		&i.FallbackModel,
		&i.McpServers,
		&i.EnableContinue,
		&i.ContinueMinutes,
	)
	return i, err
}

const failJob = `-- name: FailJob :exec
UPDATE job_queue
SET 
    job_status = CASE 
        WHEN retry_count >= max_retries THEN 'failed'
        ELSE 'pending'
    END,
    retry_count = retry_count + 1,
    error_message = ?,
    visibility_timeout = NULL,
    worker_id = NULL
WHERE id = ? AND job_status = 'processing'
`

type FailJobParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           int64          `json:"id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.ExecContext(ctx, failJob, arg.ErrorMessage, arg.ID)
	return err
}

const getJobStatus = `-- name: GetJobStatus :one
SELECT id, webhook_id, api_key_id, prompt, job_status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at, working_dir, max_thinking_tokens, max_turns, custom_system_prompt, append_system_prompt, allowed_tools, disallowed_tools, permission_mode, permission_prompt_tool_name, model, fallback_model, mcp_servers, enable_continue, continue_minutes FROM job_queue WHERE id = ?
`

func (q *Queries) GetJobStatus(ctx context.Context, id int64) (JobQueue, error) {
	row := q.db.QueryRowContext(ctx, getJobStatus, id)
	var i JobQueue
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.ApiKeyID,
		&i.Prompt,
		&i.JobStatus,
		&i.Priority,
		&i.RetryCount,
		&i.MaxRetries,
		&i.WorkerID,
		&i.VisibilityTimeout,
		&i.ErrorMessage,
		&i.Response,
		&i.ExecutionTimeMs,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.WorkingDir,
		&i.MaxThinkingTokens,
		&i.MaxTurns,
		&i.CustomSystemPrompt,
		&i.AppendSystemPrompt,
		&i.AllowedTools,
		&i.DisallowedTools,
		&i.PermissionMode,
		&i.PermissionPromptToolName,
		&i.Model,
		&i.FallbackModel,
		&i.McpServers,
		&i.EnableContinue,
		&i.ContinueMinutes,
	)
	return i, err
}

const getJobsByWebhook = `-- name: GetJobsByWebhook :many
SELECT id, webhook_id, api_key_id, prompt, job_status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at, working_dir, max_thinking_tokens, max_turns, custom_system_prompt, append_system_prompt, allowed_tools, disallowed_tools, permission_mode, permission_prompt_tool_name, model, fallback_model, mcp_servers, enable_continue, continue_minutes FROM job_queue
WHERE webhook_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetJobsByWebhookParams struct {
	WebhookID string `json:"webhook_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetJobsByWebhook(ctx context.Context, arg GetJobsByWebhookParams) ([]JobQueue, error) {
	rows, err := q.db.QueryContext(ctx, getJobsByWebhook, arg.WebhookID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobQueue{}
	for rows.Next() {
		var i JobQueue
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.ApiKeyID,
			&i.Prompt,
			&i.JobStatus,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.WorkerID,
			&i.VisibilityTimeout,
			&i.ErrorMessage,
			&i.Response,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.WorkingDir,
			&i.MaxThinkingTokens,
			&i.MaxTurns,
			&i.CustomSystemPrompt,
			&i.AppendSystemPrompt,
			&i.AllowedTools,
			&i.DisallowedTools,
			&i.PermissionMode,
			&i.PermissionPromptToolName,
			&i.Model,
			&i.FallbackModel,
			&i.McpServers,
			&i.EnableContinue,
			&i.ContinueMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingJobCount = `-- name: GetPendingJobCount :one
SELECT COUNT(*) as count FROM job_queue WHERE job_status = 'pending'
`

func (q *Queries) GetPendingJobCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingJobCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentJobs = `-- name: GetRecentJobs :many
SELECT id, webhook_id, api_key_id, prompt, job_status, priority, retry_count, max_retries, worker_id, visibility_timeout, error_message, response, execution_time_ms, created_at, started_at, completed_at, working_dir, max_thinking_tokens, max_turns, custom_system_prompt, append_system_prompt, allowed_tools, disallowed_tools, permission_mode, permission_prompt_tool_name, model, fallback_model, mcp_servers, enable_continue, continue_minutes FROM job_queue
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentJobs(ctx context.Context, limit int64) ([]JobQueue, error) {
	rows, err := q.db.QueryContext(ctx, getRecentJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobQueue{}
	for rows.Next() {
		var i JobQueue
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.ApiKeyID,
			&i.Prompt,
			&i.JobStatus,
			&i.Priority,
			&i.RetryCount,
			&i.MaxRetries,
			&i.WorkerID,
			&i.VisibilityTimeout,
			&i.ErrorMessage,
			&i.Response,
			&i.ExecutionTimeMs,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.WorkingDir,
			&i.MaxThinkingTokens,
			&i.MaxTurns,
			&i.CustomSystemPrompt,
			&i.AppendSystemPrompt,
			&i.AllowedTools,
			&i.DisallowedTools,
			&i.PermissionMode,
			&i.PermissionPromptToolName,
			&i.Model,
			&i.FallbackModel,
			&i.McpServers,
			&i.EnableContinue,
			&i.ContinueMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStaleJobs = `-- name: ResetStaleJobs :exec
UPDATE job_queue
SET 
    job_status = 'pending',
    visibility_timeout = NULL,
    worker_id = NULL
WHERE job_status = 'processing' 
  AND visibility_timeout < CURRENT_TIMESTAMP
`

func (q *Queries) ResetStaleJobs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetStaleJobs)
	return err
}
